---
title: "mlr: Curve Data"
date: "`r Sys.Date()`"
output: html_document
---

# mlr: Curve Data
 
This is a short demo for the `mlr` branch `fda`. The main goal of `fda` is to provide a tool for processing functional data within `mlr`. Within this branch, we provide preprocessing function which extract non-temporal/non-functional features such as fourier or wavelet features. And additionally, we provide direct learning algorithms for functional data. 
The currently supported preprocessing functions are:
* discrete wavelet transform
* fast fourier transform
* functional linear array model

And the supported direct learning algorithms are:
* shapelet model learning (pkg: shapeletLib from gitHub/lbeggel)
* generalized linear model (pkg: fda.usc)
* knn classification (pkg: fda.usc)
* kernel classification (pkg: fda.usc)
* np (non-parametric with bandwith) classification (pkg: fda.usc) 

With these functions, the classification methods are more precisely for functional data, i.e. the convention on the learner name is ``fdaclassif.<R_method_name>``:

```{r}
## Shapelet model 
shapelet.lrn = lrn = makeLearner("fdaclassif.shapelet")

## glm learners
glm.lrn = makeLearner("fdaclassif.glm")

## knn learner
knn.lrn = makeLearner("fdaclassif.knn")

## kernel learner
kernel.lrn = makeLearner("fdaclassif.kernel")

## Nonparametric with bandwith 
np.lrn = makeLearner("fdaclassif.np")
```

The main structure of the new learners remains unchanged compared to the other `mlr` learners. 
Currently, we can process only univariate functional data!

## Example

As demo-data, we use the gun-point data set available from the UCR time series archive (www.cs.ucr.edu/~eamonn/time_series_data/), which is a binary classification problem, with the given train-test split.
It is currently also stored in the ``demo4FDA`` folder. You can load it with 


```{r}
library(devtools)
library(BBmisc)
load_all()
 
## Load curve data
gp = load2("demo4FDA/gunpoint.RData")
```

In the following, we will show a very basic and short tutorial on how to handle functional data with this branch.

The first step is to create a functional data classification task in which the relevant information is stored, i.e. data, target variable, etc . Thus the type is “fdaclassif” and class is “FDAClassifTask”

```{r}
## Define the task:
taskCl = makeFDAClassifTask(data = gp, target = "X1", positive = "1")
print(taskCl)
class(taskCl)
 
```



## Non temporal
 
First, we can handle functional data by ignoring the temporal structure, i.e. the functional covariate is treated as (independent) measuremts. 
The basic `mlr` step is to define which learner is used for classification. We choose a CART tree. The last steps are training the model i.e. the learner, predicting and evaluation.  Currently, we hacked the “classif”-learner structure to accept “fdaclassif” objects. We need to fix this, but this requires basic mlr changes.

```{r}
## Define the learner:
lrn = makeLearner("classif.rpart")
print(lrn)
 
## Train the model on the training data of specified task:
model = train(lrn, taskCl, subset = 1:50)

## ...and predict for the test data:
pred = predict(model, taskCl, subset = 51:200)

## Get the mean misclassification error and true positive rate:
p = performance(pred, measures = list(mmce, tpr))
print(p)
```

## Preprocessing functions

Now we use the functions for preprocessing from the ``fda`` branch. These create  non-functional features from the temporal data. Currently, discrete wavelet transform, fast fourier transform, functional linear array model are available. FIX ME!
To transform raw functional data into non-functional feature data, we use the function  ``convertFDATaskToNormalTask`` on an task object of type  ``fdaclassif``. The basic structure is
``convertFDATaskToNormalTask(task, method, pars)``
where the `method` argument specifies the preprocessing method. 
The separate extraction function is called ``extractFDAFeatures``.
Examples:

## Wavelets
To begin with, we choose the discrete wavelet feature transformation.
We can specify which feature extraction method is used via `method = "wavelets"`  and add additional parameters (i.e. the `filter` and the `boundary`) in the `pars` argument.
This functions returns a classification task of type `classif` since the raw data contained temporal structure but the transformed data does not inherit temporal structure anymore:

```{r}
## Specify the feature extraction method and generate new task.
## Here, we use the Haar filter:
taskW = convertFDATaskToNormalTask(task = taskCl, method = "wavelets", pars = list(filter = "haar"))
print(taskW)
```
We also want to evaluate a the Daubechie wavelet with filter length of 4.

```{r}
## Use the Daubechie wavelet with filter length 4.
taskWD4 = convertFDATaskToNormalTask(task = taskCl, method = "wavelets", pars = list(filter = "d4"))
print(taskWD4)
```
The transformation depends on the function `getFDAWaveletFeatures`.

## Fourier transform
Now, we use the fourier feature transformation. Either the amplitude or the phase of the complex fourier coefficients can be used for analysis and can be specified in the additional `fft.coeff` argument:

```{r}
## Specify the feature extraction method and generate new task.
## We use the fourier features and the amplitude:
taskFa = convertFDATaskToNormalTask(task = taskCl, method = "fourier", pars = list(fft.coeff = "amplitude"))
print(taskFa)
## ... or we prefer the phase:
taskFp = convertFDATaskToNormalTask(task = taskCl, method = "fourier", pars = list(fft.coeff = "phase"))
print(taskFp)
```
This transformation uses the function `getFDAFourierFeatures`.





## Learners
In contrast to the preprocessing functions, the direct learning algorithms learn classification models. Thus, (as stated above) ``RLearner``s need to be defined.
An important function is the ``makeFDAClassifTask(data, target, positive)``. Creates a functional data task, type ``fdaclassif``

## Shapelet Model

The shapelet model approach learns a specific object of type ``ShapeletModel``. For this, the learning approach jointly learns shapelets which are representative for classification and a SVM type of model with which the classification is carried out. The learned shapelets are used to transform raw functional data into non-temporal feature data. Classification can then be performed with the learned SVM setting. It is important to notice that the transformation and classification setting is not independent from training!
```{r}
## Data:
gp = load2("demo4FDA/gunpoint.RData")
## Define the task:
task = makeFDAClassifTask(data = gp, target = "X1", positive = "1")
```

Next, an RLearner must be defined for the shapelet model transformation. It is called `fdaclassif.shapelet`, corresponding to the new `fdaclassif` task type. This also defines the training and prediction step. In training, the shapelets and the SVM setting are learned, in the prediction step the data to be analyzed is transformed with those learned shapelets and classified with the learned SVM parameters.

```{r}
## Define the learner:
library(shapeletLib)
lrn = makeLearner("fdaclassif.shapelet")
```
There are many parameters (number of shapelets, stepsize, ...) which can be further specified, but please have a look at package ``shapeletLib`` for further details.

Now, the basic mlr-learner structure can be used: train and predict.
```{r}
## Train the model:
model = train(lrn, task, subset = 1:50 )
## Predict the classification for new data:
pred = predict(model, task, subset = 51:200)
```
The same structure can be applied for the other implemented fda-learners. See the Architecture / RLearners doc which ones are available. FIXME

For the learners from package fda.usc, for example, we use the package example data set. 
The same structure as in the following example applies.

```{r}
library(fda.usc)
data(phoneme)
names(phoneme)
#250 curves, 150 points (250 x 150) in $learn$data, class: 5 levels

#training information
mlearn = phoneme[["learn"]]
#label information
glearn = phoneme[["classlearn"]]
ph = as.data.frame(mlearn$data)
ph[,"label"] = glearn

mtest = phoneme[["test"]]
gtest = phoneme[["classtest"]]
newdat = as.data.frame(mtest$data)

#define the learner:
lrn = makeLearner("fdaclassif.knn")
# Create a FDA classification task
task = makeFDAClassifTask(data = ph, target = "label")
#Train the model:
model = train(lrn, task)
#Predict:
pred = predict(object = model, newdata = newdat)
#Class predictions are available via $data:
pred$data
```

Now let’s try out the ‘glm’ learner: it fits a generalized linear model on functional data.

```{r}
lrn = makeLearner("fdaclassif.glm")
task = makeFDAClassifTask(data = ph, target = "label")

model = train(lrn, task)
pred = predict(object = model, newdata = newdat)
pred$data
table(gtest, as.factor(unlist(pred$data)))
```


